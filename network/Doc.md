################################################
#		网络编程笔记
#
################################################

#1. listen函数
	服务端完成监听端口后，就可以接受客户端的请求
	其第二个参数 backlog 制我们的已连接队列里等待accept()取走的连接的最大数


#2. SIGPIPE 问题
	当服务端close一个连接时，如果客户端继续使用send或write发送数据，根据TCP协议的规定，
	会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，
	告诉进程这个连接已经断开了，不要再写了。又或者当一个进程向某个已经收到RST的socket执行写操作是，
	内核向该进程发送一个SIGPIPE信号。该信号的缺省学位是终止进程，因此进程必须捕获它以免不情愿的被终止


#3. Linux 系统
	默认情况下：所有的socket都是阻塞的

#4. Socket close() 与 shutdown()区别
	close() 函数关闭套接字，并将套接字描述符从内存中清除
	shutdown() 关闭连接，但是套接字依然存在于内存中，只有调用close才能将套接字缓存从内存中清除
	
	默认情况下 close()函数不管数据有没有发送完毕，会立即向网络发送FIN包，这样会导致缓存的数据丢失；
	而shutdown函数会等缓存数据传输完毕再向网络发送FIN包
